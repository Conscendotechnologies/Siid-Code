name: Siid-Code Auto-Version & Release

on:
  push:
    branches: 
      - main
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type (auto/major/minor/patch)'
        required: false
        type: choice
        options:
          - auto
          - major
          - minor
          - patch
        default: 'auto'
      prerelease:
        description: 'Mark as pre-release/preview'
        required: false
        type: boolean
        default: false

jobs:
  # Job 1: PR Quality Checks (runs on pull requests)
  pr-checks:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: '10.8.1'
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.19.2'
          cache: 'pnpm'
          
      - name: Install dependencies
        run: pnpm install --no-frozen-lockfile
        
      - name: Run linting
        run: pnpm lint
        
      - name: Run type checking
        run: pnpm check-types
        
      - name: Run formatting check
        run: pnpm format
        
      - name: Build project
        run: pnpm build
        
      - name: Check build output
        run: |
          echo "âœ… Build completed successfully!"
          if [ -d "out" ]; then
            echo "ðŸ“ Build output (out directory):"
            ls -la out/ | head -10
            echo "ðŸ“¦ Bundle size (out):"
            du -sh out/
          fi
          if [ -d "dist" ]; then
            echo "ðŸ“ Build output (dist directory):"
            ls -la dist/ | head -10
            echo "ðŸ“¦ Bundle size (dist):"
            du -sh dist/
          fi
          
      - name: Security audit
        run: |
          pnpm audit --audit-level moderate || echo "âš ï¸ Security audit completed with warnings"
          
      - name: Check package.json scripts
        run: |
          echo "ðŸ“‹ Available scripts:"
          node -p "Object.keys(require('./package.json').scripts || {}).join('\n')"
          
      - name: Analyze commit message
        run: |
          echo "## ðŸ“ Commit Message Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          COMMIT_MSG=$(git log -1 --pretty=format:"%s")
          echo "**Latest commit:** \`$COMMIT_MSG\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if echo "$COMMIT_MSG" | grep -qiE "^(feat|fix|docs|chore|refactor|perf|test|style|ci)(\(.*\))?:"; then
            echo "âœ… Commit follows conventional commit format" >> $GITHUB_STEP_SUMMARY
            
            if echo "$COMMIT_MSG" | grep -qiE "^feat!:|^fix!:|BREAKING CHANGE"; then
              echo "ðŸ”´ **MAJOR** version bump (breaking change)" >> $GITHUB_STEP_SUMMARY
            elif echo "$COMMIT_MSG" | grep -qiE "^feat(\(.*\))?:"; then
              echo "ðŸŸ¡ **MINOR** version bump (new feature)" >> $GITHUB_STEP_SUMMARY
            elif echo "$COMMIT_MSG" | grep -qiE "^fix(\(.*\))?:"; then
              echo "ðŸŸ¢ **PATCH** version bump (bug fix)" >> $GITHUB_STEP_SUMMARY
            else
              echo "ðŸŸ¢ **PATCH** version bump (maintenance)" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âš ï¸ Commit does not follow conventional commit format" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Recommended format:**" >> $GITHUB_STEP_SUMMARY
            echo "- \`feat: add new feature\` (MINOR bump)" >> $GITHUB_STEP_SUMMARY
            echo "- \`fix: resolve bug\` (PATCH bump)" >> $GITHUB_STEP_SUMMARY
            echo "- \`feat!: breaking change\` (MAJOR bump)" >> $GITHUB_STEP_SUMMARY
          fi
          
      - name: PR Status Summary
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## âœ… All PR Checks Passed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ” Linting | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ“ Type Checking | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ’… Formatting | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ”¨ Build | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ”’ Security Audit | âœ… Checked |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ¨ **This PR is ready for review and merge!**" >> $GITHUB_STEP_SUMMARY

  # Job 2: Auto-Version and Release (runs on push to main)
  auto-version-and-release:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: '10.8.1'
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.19.2'
          cache: 'pnpm'
          
      - name: Get latest tag
        id: get_latest_tag
        run: |
          echo "ðŸ” Searching for latest CalVer tag (YEAR.MAJOR.MINOR format)..."
          
          # Get all v*.*.* tags
          ALL_TAGS=$(git tag -l "v*.*.*")
          
          # Filter to ONLY CalVer versions (YEAR >= 2000)
          LATEST_TAG=$(echo "$ALL_TAGS" | while read tag; do
            if [ -n "$tag" ]; then
              VERSION=${tag#v}
              IFS='.' read -r YEAR MAJOR MINOR <<< "$VERSION"
              # Only include tags where YEAR >= 2000 (CalVer versions)
              if [ "$YEAR" -eq "$YEAR" ] 2>/dev/null && [ "$YEAR" -ge 2000 ]; then
                echo "$tag"
              fi
            fi
          done | sort -t. -k1,1n -k2,2n -k3,3n | tail -n 1)
          
          # Get current year
          CURRENT_YEAR=$(date +'%Y')
          
          # If no CalVer tag found, start fresh with current year
          if [ -z "$LATEST_TAG" ]; then
            echo "âš ï¸  No CalVer tags found"
            echo "âœ¨ Starting fresh with v$CURRENT_YEAR.0.0"
            LATEST_TAG="v$CURRENT_YEAR.0.0"
            IS_FIRST_RELEASE="true"
          else
            echo "âœ… Found latest CalVer version: $LATEST_TAG"
            IS_FIRST_RELEASE="false"
          fi
          
          # Extract version numbers (remove 'v' prefix)
          VERSION=${LATEST_TAG#v}
          
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "current_version=$VERSION" >> $GITHUB_OUTPUT
          echo "is_first_release=$IS_FIRST_RELEASE" >> $GITHUB_OUTPUT
          echo ""
          echo "ðŸ“Œ Using version: $LATEST_TAG"
          
      - name: Analyze commits for version bump
        id: analyze_commits
        run: |
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"
          IS_FIRST_RELEASE="${{ steps.get_latest_tag.outputs.is_first_release }}"
          
          if [ "$IS_FIRST_RELEASE" = "true" ]; then
            echo "ðŸŽ‰ First CalVer release - analyzing recent commits"
            COMMITS=$(git log --pretty=format:"%s" --no-merges -20)
          else
            echo "ðŸ“Œ Analyzing commits since: $LATEST_TAG"
            
            # Check if the tag actually exists in the repository
            if git rev-parse "$LATEST_TAG" >/dev/null 2>&1; then
              COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"%s" --no-merges)
            else
              echo "âš ï¸  Tag $LATEST_TAG does not exist in repository"
              echo "ðŸ“ Analyzing recent commits (last 20)"
              COMMITS=$(git log --pretty=format:"%s" --no-merges | head -20)
            fi
          fi
          
          echo "Commits analyzed:"
          echo "$COMMITS"
          echo ""
          
          # Determine bump type based on conventional commits
          BUMP_TYPE="patch"
          
          # Check for breaking changes (MAJOR)
          if echo "$COMMITS" | grep -qiE "^(BREAKING CHANGE:|feat!:|fix!:|refactor!:)"; then
            BUMP_TYPE="major"
            echo "ðŸ”´ BREAKING CHANGE detected â†’ MAJOR version bump"
          # Check for new features (MINOR)
          elif echo "$COMMITS" | grep -qiE "^feat(\(.*\))?:"; then
            BUMP_TYPE="minor"
            echo "ðŸŸ¡ New feature detected â†’ MINOR version bump"
          # Check for fixes or other changes (PATCH)
          elif echo "$COMMITS" | grep -qiE "^(fix|perf|refactor|docs|chore|style|test)(\(.*\))?:"; then
            BUMP_TYPE="patch"
            echo "ðŸŸ¢ Fix/improvement detected â†’ PATCH version bump"
          else
            BUMP_TYPE="patch"
            echo "âšª No conventional commits â†’ default PATCH version bump"
          fi
          
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          
      - name: Calculate new version
        id: calc_version
        run: |
          CURRENT_VERSION="${{ steps.get_latest_tag.outputs.current_version }}"
          IS_FIRST_RELEASE="${{ steps.get_latest_tag.outputs.is_first_release }}"
          BUMP_TYPE="${{ github.event.inputs.version_bump || steps.analyze_commits.outputs.bump_type }}"
          PRERELEASE="${{ github.event.inputs.prerelease }}"
          
          echo "Current version: $CURRENT_VERSION"
          echo "First release: $IS_FIRST_RELEASE"
          echo "Bump type: $BUMP_TYPE"
          echo "Prerelease: $PRERELEASE"
          echo ""
          
          # Get current year
          CURRENT_YEAR=$(date +'%Y')
          
          if [ "$IS_FIRST_RELEASE" = "true" ]; then
            # This is the first CalVer release
            NEW_VERSION="$CURRENT_YEAR.0.0"
            echo "ðŸŽ‰ First CalVer release: $NEW_VERSION"
          else
            # Parse current version (format: YEAR.MAJOR.MINOR or YEAR.MAJOR.MINOR-alpha.X)
            # Remove any prerelease suffix first
            BASE_VERSION="${CURRENT_VERSION%%-*}"
            IFS='.' read -r YEAR MAJOR MINOR <<< "$BASE_VERSION"
            
            # If year changed, reset to YEAR.0.0
            if [ "$YEAR" != "$CURRENT_YEAR" ]; then
              NEW_VERSION="$CURRENT_YEAR.0.0"
              echo "ðŸ“… New year detected! Resetting to $NEW_VERSION"
            else
              # Apply version bump based on CalVer rules
              case $BUMP_TYPE in
                major)
                  MAJOR=$((MAJOR + 1))
                  MINOR=0
                  echo "ðŸ”´ MAJOR bump: $CURRENT_VERSION â†’ $CURRENT_YEAR.$MAJOR.$MINOR"
                  ;;
                minor)
                  MINOR=$((MINOR + 1))
                  echo "ðŸŸ¡ MINOR bump: $CURRENT_VERSION â†’ $CURRENT_YEAR.$MAJOR.$MINOR"
                  ;;
                patch|auto)
                  MINOR=$((MINOR + 1))
                  echo "ðŸŸ¢ PATCH bump (increments MINOR in CalVer): $CURRENT_VERSION â†’ $CURRENT_YEAR.$MAJOR.$MINOR"
                  ;;
              esac
              
              # Build version string (with or without prerelease suffix)
              if [ "$PRERELEASE" = "true" ]; then
                NEW_VERSION="$CURRENT_YEAR.$MAJOR.$MINOR-alpha.$MINOR"
                echo "ðŸ”µ Prerelease version: $NEW_VERSION"
              else
                NEW_VERSION="$CURRENT_YEAR.$MAJOR.$MINOR"
                echo "âœ… Stable version: $NEW_VERSION"
              fi
            fi
          fi
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "new_tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
          
      - name: Check if version already exists
        id: check_version
        run: |
          NEW_TAG="${{ steps.calc_version.outputs.new_tag }}"
          
          if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
            echo "âš ï¸  Tag $NEW_TAG already exists!"
            echo "version_exists=true" >> $GITHUB_OUTPUT
          else
            echo "âœ… Tag $NEW_TAG is available"
            echo "version_exists=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Update package.json version
        if: steps.check_version.outputs.version_exists == 'false'
        run: |
          NEW_VERSION="${{ steps.calc_version.outputs.new_version }}"
          echo "ðŸ“ Updating package.json to version $NEW_VERSION"
          
          # Get current package.json version
          CURRENT_PKG_VERSION=$(node -p "require('./src/package.json').version")
          echo "Current package.json version: $CURRENT_PKG_VERSION"
          
          # Update version in package.json (only if different)
          if [ "$CURRENT_PKG_VERSION" != "$NEW_VERSION" ]; then
            node -e "
              const fs = require('fs');
              const pkg = JSON.parse(fs.readFileSync('./src/package.json', 'utf8'));
              pkg.version = '$NEW_VERSION';
              fs.writeFileSync('./src/package.json', JSON.stringify(pkg, null, 2) + '\n');
            "
            echo "âœ… package.json version updated to: $NEW_VERSION"
          else
            echo "â„¹ï¸  package.json already at version $NEW_VERSION, skipping update"
          fi
          
          # Verify the changes
          PACKAGE_VERSION=$(node -p "require('./src/package.json').version")
          echo "âœ… Final package.json version: $PACKAGE_VERSION"
          
      - name: Commit version bump
        if: steps.check_version.outputs.version_exists == 'false'
        run: |
          NEW_VERSION="${{ steps.calc_version.outputs.new_version }}"
          
          # Check if there are any changes to commit
          if git diff --quiet src/package.json; then
            echo "â„¹ï¸  No version changes detected, skipping commit"
          else
            # Configure git
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            
            # Commit and push
            git add src/package.json
            git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
            git push
            
            echo "âœ… Version changes committed and pushed to main branch"
          fi
          
      - name: Install dependencies
        if: steps.check_version.outputs.version_exists == 'false'
        run: pnpm install --no-frozen-lockfile
        
      - name: Run linting
        if: steps.check_version.outputs.version_exists == 'false'
        run: pnpm lint
        
      - name: Run type checking
        if: steps.check_version.outputs.version_exists == 'false'
        run: pnpm check-types
        
      - name: Build project
        if: steps.check_version.outputs.version_exists == 'false'
        run: pnpm build
        
      - name: Check build output
        if: steps.check_version.outputs.version_exists == 'false'
        run: |
          echo "Build completed successfully!"
          if [ -d "out" ]; then
            echo "ðŸ“ Build output (out directory):"
            ls -la out/ | head -10
          fi
          if [ -d "dist" ]; then
            echo "ðŸ“ Build output (dist directory):"
            ls -la dist/ | head -10
          fi
          
      - name: Create VSIX package
        if: steps.check_version.outputs.version_exists == 'false'
        run: pnpm vsix
        
      - name: Find VSIX file
        if: steps.check_version.outputs.version_exists == 'false'
        id: find_vsix
        run: |
          # Look for VSIX files in common locations
          VSIX_FILE=""
          if [ -d "bin" ] && [ "$(ls bin/*.vsix 2>/dev/null | wc -l)" -gt 0 ]; then
            VSIX_FILE=$(ls bin/*.vsix | head -1)
          elif [ "$(ls *.vsix 2>/dev/null | wc -l)" -gt 0 ]; then
            VSIX_FILE=$(ls *.vsix | head -1)
          fi
          
          if [ -n "$VSIX_FILE" ]; then
            echo "Found VSIX: $VSIX_FILE"
            echo "vsix_path=$VSIX_FILE" >> $GITHUB_OUTPUT
            echo "vsix_name=$(basename $VSIX_FILE)" >> $GITHUB_OUTPUT
          else
            echo "Error: No VSIX file found!"
            exit 1
          fi
          
      - name: Generate checksums
        if: steps.check_version.outputs.version_exists == 'false'
        id: checksums
        run: |
          VSIX_FILE="${{ steps.find_vsix.outputs.vsix_path }}"
          SHA256=$(sha256sum "$VSIX_FILE" | awk '{print $1}')
          echo "$SHA256" > "${VSIX_FILE}.sha256"
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "âœ“ Checksum generated"
          echo "SHA256: $SHA256"
          
      - name: Get build timestamp
        id: timestamp
        run: |
          echo "build_date=$(date +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          echo "build_date_compact=$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_OUTPUT
          
      - name: Generate changelog
        id: changelog
        run: |
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"
          IS_FIRST_RELEASE="${{ steps.get_latest_tag.outputs.is_first_release }}"
          
          if [ "$IS_FIRST_RELEASE" = "true" ]; then
            echo "ðŸŽ‰ First CalVer release - showing recent commits"
            COMMITS=$(git log --pretty=format:"- %s by @%an in %h" --no-merges -20)
          else
            echo "ðŸ“‹ Generating changelog from $LATEST_TAG to HEAD"
            
            # Check if the tag actually exists in the repository
            if git rev-parse "$LATEST_TAG" >/dev/null 2>&1; then
              COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"- %s by @%an in %h" --no-merges)
            else
              echo "âš ï¸  Tag $LATEST_TAG does not exist in repository"
              echo "ðŸ“ Showing recent commits (last 20)"
              COMMITS=$(git log --pretty=format:"- %s by @%an in %h" --no-merges -20)
            fi
          fi
          
          # Check if there are any commits
          if [ -z "$COMMITS" ]; then
            COMMITS="- No changes since last release"
          fi
          
          # Save to file
          echo "$COMMITS" > changelog.txt
          
          # Read into output
          CHANGELOG=$(cat changelog.txt)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      - name: Get contributors
        id: contributors
        run: |
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"
          IS_FIRST_RELEASE="${{ steps.get_latest_tag.outputs.is_first_release }}"
          
          if [ "$IS_FIRST_RELEASE" = "true" ]; then
            CONTRIBUTORS=$(git log --pretty=format:"%an" --no-merges | sort -u | head -10 | sed 's/^/@/' | paste -sd ", " -)
          else
            if git rev-parse "$LATEST_TAG" >/dev/null 2>&1; then
              CONTRIBUTORS=$(git log $LATEST_TAG..HEAD --pretty=format:"%an" --no-merges | sort -u | sed 's/^/@/' | paste -sd ", " -)
            else
              CONTRIBUTORS=$(git log --pretty=format:"%an" --no-merges | sort -u | head -10 | sed 's/^/@/' | paste -sd ", " -)
            fi
          fi
          
          if [ -z "$CONTRIBUTORS" ]; then
            CONTRIBUTORS="@${{ github.actor }}"
          fi
          
          echo "contributors=$CONTRIBUTORS" >> $GITHUB_OUTPUT
          
      - name: Create Release
        if: steps.check_version.outputs.version_exists == 'false'
        uses: softprops/action-gh-release@v1
        with:
          name: "SIID Code Extension v${{ steps.calc_version.outputs.new_version }}"
          tag_name: ${{ steps.calc_version.outputs.new_tag }}
          draft: false
          prerelease: ${{ github.event.inputs.prerelease || 'false' }}
          generate_release_notes: false
          body: |
            ## SIID Code Extension Package
            
            **Build Date:** ${{ steps.timestamp.outputs.build_date }}
            **Version:** v${{ steps.calc_version.outputs.new_version }}
            **Version Bump:** ${{ steps.analyze_commits.outputs.bump_type }}
            
            ---
            
            ### ðŸ“¦ Downloads
            
            | Package | Description |
            |---------|-------------|
            | **${{ steps.find_vsix.outputs.vsix_name }}** | VS Code Extension Package (install via Extensions view or `code --install-extension`) |
            
            ### ðŸ” Checksums
            Use the .sha256 files to verify your download integrity.
            
            ---
            
            ### ðŸ“ What's Changed
            
            ${{ steps.changelog.outputs.changelog }}
            
            **Full Changelog:** ${{ github.server_url }}/${{ github.repository }}/compare/${{ steps.get_latest_tag.outputs.latest_tag }}...${{ steps.calc_version.outputs.new_tag }}
            
            ---
            
            ### ðŸ‘¥ Contributors
            
            ${{ steps.contributors.outputs.contributors }}
            
            ---
            
            ### ðŸ“‹ Version Information
            
            SIID Code follows **Calendar Versioning (CalVer)**: `YEAR.MAJOR.MINOR`
            - **YEAR**: Current year (e.g., 2025)
            - **MAJOR**: Breaking changes or significant new features
            - **MINOR**: New features (backward compatible) or bug fixes
            - Version resets at year boundary (e.g., 2025.x.x â†’ 2026.0.0)
          files: |
            ${{ steps.find_vsix.outputs.vsix_path }}
            ${{ steps.find_vsix.outputs.vsix_path }}.sha256
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Upload Build Artifacts
        if: steps.check_version.outputs.version_exists == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: siid-code-extension-v${{ steps.calc_version.outputs.new_version }}
          path: |
            ${{ steps.find_vsix.outputs.vsix_path }}
            ${{ steps.find_vsix.outputs.vsix_path }}.sha256
          retention-days: 90
          
      - name: Summary
        if: always()
        run: |
          echo "## ðŸ“Š Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Previous Version | \`${{ steps.get_latest_tag.outputs.latest_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| New Version | \`${{ steps.calc_version.outputs.new_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Bump Type | **${{ steps.analyze_commits.outputs.bump_type }}** |" >> $GITHUB_STEP_SUMMARY
          echo "| Build Date | ${{ steps.timestamp.outputs.build_date }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version Exists | ${{ steps.check_version.outputs.version_exists }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Prerelease | ${{ github.event.inputs.prerelease || 'false' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check_version.outputs.version_exists }}" == "true" ]; then
            echo "### âš ï¸ Warning" >> $GITHUB_STEP_SUMMARY
            echo "Version ${{ steps.calc_version.outputs.new_tag }} already exists. Build was skipped." >> $GITHUB_STEP_SUMMARY
          else
            echo "### âœ… Success" >> $GITHUB_STEP_SUMMARY
            echo "Release ${{ steps.calc_version.outputs.new_tag }} created successfully!" >> $GITHUB_STEP_SUMMARY
          fi
